"use strict";
var _a, _Rule_severity, _Rule_enabled, _Rule_then, _Rule_given, _Rule_resolveAlias, _Rule_resolveAliasForFormats;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Rule = void 0;
const tslib_1 = require("tslib");
const lodash_1 = require("lodash");
const path_1 = require("@stoplight/path");
const json_1 = require("@stoplight/json");
const spectral_runtime_1 = require("@stoplight/spectral-runtime");
const severity_1 = require("./utils/severity");
const minimatch_1 = require("./utils/minimatch");
const formats_1 = require("./formats");
const guards_1 = require("./utils/guards");
const ALIAS = /^#([A-Za-z0-9_-]+)/;
class Rule {
    constructor(name, definition, owner) {
        var _b, _c, _d;
        this.name = name;
        this.definition = definition;
        this.owner = owner;
        _Rule_severity.set(this, void 0);
        _Rule_enabled.set(this, void 0);
        _Rule_then.set(this, void 0);
        _Rule_given.set(this, void 0);
        this.recommended = definition.recommended !== false;
        (0, tslib_1.__classPrivateFieldSet)(this, _Rule_enabled, this.recommended, "f");
        this.description = (_b = definition.description) !== null && _b !== void 0 ? _b : null;
        this.message = (_c = definition.message) !== null && _c !== void 0 ? _c : null;
        this.documentationUrl = (_d = definition.documentationUrl) !== null && _d !== void 0 ? _d : null;
        this.severity = definition.severity;
        this.resolved = definition.resolved !== false;
        this.formats = 'formats' in definition ? new formats_1.Formats(definition.formats) : null;
        this.then = definition.then;
        this.given = definition.given;
    }
    get enabled() {
        return (0, tslib_1.__classPrivateFieldGet)(this, _Rule_enabled, "f") || this.overrides !== void 0;
    }
    set enabled(enabled) {
        (0, tslib_1.__classPrivateFieldSet)(this, _Rule_enabled, enabled, "f");
    }
    getSeverityForSource(source, path) {
        if (this.overrides === void 0 || this.overrides.definition.size === 0) {
            return this.severity;
        }
        const relativeSource = (0, path_1.relative)((0, path_1.dirname)(this.overrides.rulesetSource), source);
        const relevantOverrides = [];
        for (const [source, override] of this.overrides.definition.entries()) {
            if ((0, minimatch_1.minimatch)(relativeSource, source)) {
                relevantOverrides.push(override);
            }
        }
        if (relevantOverrides.length === 0) {
            return this.severity;
        }
        let severity = this.severity;
        let closestPointer = '';
        const pointer = (0, json_1.pathToPointer)(path);
        for (const relevantOverride of relevantOverrides) {
            for (const [overridePath, overrideSeverity] of relevantOverride.entries()) {
                if (overridePath.length >= closestPointer.length && pointer.startsWith(overridePath)) {
                    closestPointer = overridePath;
                    severity = overrideSeverity;
                }
            }
        }
        return severity;
    }
    get severity() {
        return (0, tslib_1.__classPrivateFieldGet)(this, _Rule_severity, "f");
    }
    set severity(severity) {
        if (severity === void 0) {
            (0, tslib_1.__classPrivateFieldSet)(this, _Rule_severity, severity_1.DEFAULT_SEVERITY_LEVEL, "f");
        }
        else {
            (0, tslib_1.__classPrivateFieldSet)(this, _Rule_severity, (0, severity_1.getDiagnosticSeverity)(severity), "f");
        }
    }
    get then() {
        return (0, tslib_1.__classPrivateFieldGet)(this, _Rule_then, "f");
    }
    set then(then) {
        (0, tslib_1.__classPrivateFieldSet)(this, _Rule_then, Array.isArray(then) ? then : [then], "f");
    }
    get given() {
        return (0, tslib_1.__classPrivateFieldGet)(this, _Rule_given, "f");
    }
    set given(given) {
        const actualGiven = Array.isArray(given) ? given : [given];
        (0, tslib_1.__classPrivateFieldSet)(this, _Rule_given, this.owner.hasComplexAliases
            ? actualGiven
            : actualGiven.flatMap(expr => (0, tslib_1.__classPrivateFieldGet)(Rule, _a, "m", _Rule_resolveAlias).call(Rule, this.owner.aliases, expr, null, new Set())).filter(lodash_1.isString), "f");
    }
    getGivenForFormats(formats) {
        return this.owner.hasComplexAliases
            ? (0, tslib_1.__classPrivateFieldGet)(this, _Rule_given, "f").flatMap(expr => (0, tslib_1.__classPrivateFieldGet)(Rule, _a, "m", _Rule_resolveAlias).call(Rule, this.owner.aliases, expr, formats, new Set()))
            : (0, tslib_1.__classPrivateFieldGet)(this, _Rule_given, "f");
    }
    matchesFormat(formats) {
        if (this.formats === null) {
            return true;
        }
        if (formats === null) {
            return false;
        }
        for (const format of formats) {
            if (this.formats.has(format)) {
                return true;
            }
        }
        return false;
    }
    clone() {
        return new Rule(this.name, this.definition, this.owner);
    }
    toJSON() {
        return {
            name: this.name,
            recommended: this.recommended,
            enabled: this.enabled,
            description: this.description,
            message: this.message,
            documentationUrl: this.documentationUrl,
            severity: this.severity,
            resolved: this.resolved,
            formats: this.formats,
            then: this.then.map(then => ({
                ...then.function,
                function: then.function.name,
                ...('functionOptions' in then ? { functionOptions: (0, spectral_runtime_1.printValue)(then.functionOptions) } : null),
            })),
            given: Array.isArray(this.definition.given) ? this.definition.given : [this.definition.given],
            owner: this.owner.id,
        };
    }
}
exports.Rule = Rule;
_a = Rule, _Rule_severity = new WeakMap(), _Rule_enabled = new WeakMap(), _Rule_then = new WeakMap(), _Rule_given = new WeakMap(), _Rule_resolveAlias = function _Rule_resolveAlias(aliases, expr, formats, stack) {
    var _b;
    const resolvedExpressions = [];
    if (expr.startsWith('#')) {
        const alias = (_b = ALIAS.exec(expr)) === null || _b === void 0 ? void 0 : _b[1];
        if (alias === void 0 || alias === null) {
            throw new ReferenceError(`"${this.name}" rule references an invalid alias`);
        }
        if (stack.has(alias)) {
            const _stack = [...stack, alias];
            throw new ReferenceError(`Alias "${_stack[0]}" is circular. Resolution stack: ${_stack.join(' -> ')}`);
        }
        stack.add(alias);
        if (aliases === null || !(alias in aliases)) {
            throw new ReferenceError(`Alias "${alias}" does not exist`);
        }
        const aliasValue = aliases[alias];
        let actualAliasValue;
        if ((0, guards_1.isSimpleAliasDefinition)(aliasValue)) {
            actualAliasValue = aliasValue;
        }
        else {
            actualAliasValue = (0, tslib_1.__classPrivateFieldGet)(Rule, _a, "m", _Rule_resolveAliasForFormats).call(Rule, aliasValue, formats);
        }
        if (actualAliasValue !== null) {
            resolvedExpressions.push(...actualAliasValue.flatMap(item => (0, tslib_1.__classPrivateFieldGet)(Rule, _a, "m", _Rule_resolveAlias).call(Rule, aliases, item + expr.slice(alias.length + 1), formats, new Set([...stack]))));
        }
    }
    else {
        resolvedExpressions.push(expr);
    }
    return resolvedExpressions;
}, _Rule_resolveAliasForFormats = function _Rule_resolveAliasForFormats({ targets }, formats) {
    if (formats === null || formats.size === 0) {
        return null;
    }
    for (let i = targets.length - 1; i >= 0; i--) {
        const target = targets[i];
        for (const format of target.formats) {
            if (formats.has(format)) {
                return target.given;
            }
        }
    }
    return null;
};
//# sourceMappingURL=rule.js.map