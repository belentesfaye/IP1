"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createValidator = void 0;
const tslib_1 = require("tslib");
const ajv_1 = (0, tslib_1.__importStar)(require("ajv"));
const ajv_formats_1 = (0, tslib_1.__importDefault)(require("ajv-formats"));
const ajv_errors_1 = (0, tslib_1.__importDefault)(require("ajv-errors"));
const ruleSchema = (0, tslib_1.__importStar)(require("../meta/rule.schema.json"));
const shared = (0, tslib_1.__importStar)(require("../meta/shared.json"));
const rulesetSchema = (0, tslib_1.__importStar)(require("../meta/ruleset.schema.json"));
const jsExtensions = (0, tslib_1.__importStar)(require("../meta/js-extensions.json"));
const jsonExtensions = (0, tslib_1.__importStar)(require("../meta/json-extensions.json"));
const message = (0, ajv_1._) `'spectral-message'`;
const validators = {
    js: null,
    json: null,
};
function createValidator(format) {
    const existingValidator = validators[format];
    if (existingValidator !== null) {
        return existingValidator;
    }
    const ajv = new ajv_1.default({
        allErrors: true,
        strict: true,
        strictRequired: false,
        keywords: ['$anchor'],
        schemas: [ruleSchema, shared],
    });
    (0, ajv_formats_1.default)(ajv);
    (0, ajv_errors_1.default)(ajv);
    ajv.addKeyword({
        keyword: 'spectral-runtime',
        schemaType: 'string',
        error: {
            message(ctx) {
                return (0, ajv_1._) `${ctx.data}[Symbol.for(${message})]`;
            },
        },
        code(cxt) {
            const { data } = cxt;
            switch (cxt.schema) {
                case 'format':
                    cxt.fail((0, ajv_1._) `typeof ${data} !== "function"`);
                    break;
                case 'ruleset-function':
                    cxt.pass((0, ajv_1._) `typeof ${data}.function === "function"`);
                    cxt.pass((0, ajv_1._) `(() => { try { ${data}.function.validator && ${data}.function.validator('functionOptions' in ${data} ? ${data} : null); } catch (e) { ${data}[${message}] = e.message } })()`);
                    break;
            }
        },
    });
    if (format === 'js') {
        ajv.addSchema(jsExtensions);
    }
    else {
        ajv.addSchema(jsonExtensions);
    }
    const validator = ajv.compile(rulesetSchema);
    validators[format] = validator;
    return validator;
}
exports.createValidator = createValidator;
//# sourceMappingURL=ajv.js.map