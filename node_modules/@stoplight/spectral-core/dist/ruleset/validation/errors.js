"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RulesetAjvValidationError = exports.RulesetValidationError = void 0;
const spectral_runtime_1 = require("@stoplight/spectral-runtime");
class RulesetValidationError extends Error {
    constructor(message) {
        super(message);
        this.message = message;
    }
}
exports.RulesetValidationError = RulesetValidationError;
const RULE_INSTANCE_PATH = /^\/rules\/[^/]+/;
const GENERIC_INSTANCE_PATH = /^\/(?:aliases|extends|overrides(?:\/\d+\/extends)?)/;
class RulesetAjvValidationError extends RulesetValidationError {
    constructor(ruleset, errors) {
        super(RulesetAjvValidationError.serializeAjvErrors(ruleset, errors));
        this.ruleset = ruleset;
        this.errors = errors;
    }
    static serializeAjvErrors(ruleset, errors) {
        const sortedErrors = [...errors]
            .sort((errorA, errorB) => {
            const diff = errorA.instancePath.length - errorB.instancePath.length;
            return diff === 0 ? (errorA.keyword === 'errorMessage' && errorB.keyword !== 'errorMessage' ? -1 : 0) : diff;
        })
            .filter((error, i, sortedErrors) => i === 0 || sortedErrors[i - 1].instancePath !== error.instancePath);
        const filteredErrors = [];
        l: for (let i = 0; i < sortedErrors.length; i++) {
            const error = sortedErrors[i];
            const prevError = i === 0 ? null : sortedErrors[i - 1];
            if (GENERIC_INSTANCE_PATH.test(error.instancePath)) {
                let x = 1;
                while (i + x < sortedErrors.length) {
                    if (sortedErrors[i + x].instancePath.startsWith(error.instancePath) ||
                        !GENERIC_INSTANCE_PATH.test(sortedErrors[i + x].instancePath)) {
                        continue l;
                    }
                    x++;
                }
            }
            else if (prevError === null) {
                filteredErrors.push(error);
                continue;
            }
            else {
                const match = RULE_INSTANCE_PATH.exec(error.instancePath);
                if (match !== null && match[0] !== match.input && match[0] === prevError.instancePath) {
                    filteredErrors.pop();
                }
            }
            filteredErrors.push(error);
        }
        return filteredErrors
            .map(({ message, instancePath }) => `Error at ${(0, spectral_runtime_1.printPath)(instancePath.slice(1).split('/'), spectral_runtime_1.PrintStyle.Pointer)}: ${message !== null && message !== void 0 ? message : ''}`)
            .join('\n');
    }
}
exports.RulesetAjvValidationError = RulesetAjvValidationError;
//# sourceMappingURL=errors.js.map