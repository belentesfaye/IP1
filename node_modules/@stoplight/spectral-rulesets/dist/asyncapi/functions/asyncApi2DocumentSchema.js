"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareResults = void 0;
const tslib_1 = require("tslib");
const spectral_core_1 = require("@stoplight/spectral-core");
const spectral_functions_1 = require("@stoplight/spectral-functions");
const spectral_formats_1 = require("@stoplight/spectral-formats");
const asyncAPI2_0_0Schema = (0, tslib_1.__importStar)(require("@asyncapi/specs/schemas/2.0.0.json"));
const asyncAPI2_1_0Schema = (0, tslib_1.__importStar)(require("@asyncapi/specs/schemas/2.1.0.json"));
const asyncAPI2_2_0Schema = (0, tslib_1.__importStar)(require("@asyncapi/specs/schemas/2.2.0.json"));
const asyncAPI2_3_0Schema = (0, tslib_1.__importStar)(require("@asyncapi/specs/schemas/2.3.0.json"));
const asyncAPI2_4_0Schema = (0, tslib_1.__importStar)(require("@asyncapi/specs/schemas/2.4.0.json"));
function shouldIgnoreError(error) {
    return (error.keyword === 'oneOf' ||
        (error.keyword === 'required' && error.params.missingProperty === '$ref'));
}
const ERROR_MAP = [
    {
        path: /^components\/securitySchemes\/[^/]+$/,
        message: 'Invalid security scheme',
    },
];
function prepareResults(errors) {
    for (const error of errors) {
        if (error.keyword === 'additionalProperties') {
            error.instancePath = `${error.instancePath}/${String(error.params['additionalProperty'])}`;
        }
    }
    for (let i = 0; i < errors.length; i++) {
        const error = errors[i];
        if (i + 1 < errors.length && errors[i + 1].instancePath === error.instancePath) {
            errors.splice(i + 1, 1);
            i--;
        }
        else if (i > 0 && shouldIgnoreError(error) && errors[i - 1].instancePath.startsWith(error.instancePath)) {
            errors.splice(i, 1);
            i--;
        }
    }
}
exports.prepareResults = prepareResults;
function applyManualReplacements(errors) {
    for (const error of errors) {
        if (error.path === void 0)
            continue;
        const joinedPath = error.path.join('/');
        for (const mappedError of ERROR_MAP) {
            if (mappedError.path.test(joinedPath)) {
                error.message = mappedError.message;
                break;
            }
        }
    }
}
function getSchema(formats) {
    switch (true) {
        case formats.has(spectral_formats_1.aas2_0):
            return asyncAPI2_0_0Schema;
        case formats.has(spectral_formats_1.aas2_1):
            return asyncAPI2_1_0Schema;
        case formats.has(spectral_formats_1.aas2_2):
            return asyncAPI2_2_0Schema;
        case formats.has(spectral_formats_1.aas2_3):
            return asyncAPI2_3_0Schema;
        case formats.has(spectral_formats_1.aas2_4):
            return asyncAPI2_4_0Schema;
        default:
            return;
    }
}
exports.default = (0, spectral_core_1.createRulesetFunction)({
    input: null,
    options: null,
}, function asyncApi2DocumentSchema(targetVal, _, context) {
    const formats = context.document.formats;
    if (formats === null || formats === void 0)
        return;
    const schema = getSchema(formats);
    if (schema === void 0)
        return;
    const errors = (0, spectral_functions_1.schema)(targetVal, { allErrors: true, schema, prepareResults }, context);
    if (Array.isArray(errors)) {
        applyManualReplacements(errors);
    }
    return errors;
});
//# sourceMappingURL=asyncApi2DocumentSchema.js.map