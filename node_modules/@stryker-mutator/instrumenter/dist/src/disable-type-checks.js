import { notEmpty } from '@stryker-mutator/util';
import { createParser, getFormat } from './parsers/index.js';
import { AstFormat } from './syntax/index.js';
const commentDirectiveRegEx = /^(\s*)@(ts-[a-z-]+).*$/;
const tsDirectiveLikeRegEx = /@(ts-[a-z-]+)/;
const startingCommentRegex = /(^\s*\/\*.*?\*\/)/gs;
export async function disableTypeChecks(file, options) {
    if (isJSFileWithoutTSDirectives(file)) {
        // Performance optimization. Only parse the file when it has a change of containing a `// @ts-` directive
        return {
            ...file,
            content: prefixWithNoCheck(file.content),
        };
    }
    const parse = createParser(options);
    const ast = await parse(file.content, file.name);
    switch (ast.format) {
        case AstFormat.JS:
        case AstFormat.TS:
        case AstFormat.Tsx:
            return { ...file, content: disableTypeCheckingInBabelAst(ast) };
        case AstFormat.Html:
            return { ...file, content: disableTypeCheckingInHtml(ast) };
    }
}
function isJSFileWithoutTSDirectives(file) {
    const format = getFormat(file.name);
    return (format === AstFormat.TS || format === AstFormat.JS) && !tsDirectiveLikeRegEx.test(file.content);
}
function disableTypeCheckingInBabelAst(ast) {
    return prefixWithNoCheck(removeTSDirectives(ast.rawContent, ast.root.comments));
}
function prefixWithNoCheck(code) {
    var _a, _b;
    if (code.startsWith('#')) {
        // first line has a shebang (#!/usr/bin/env node)
        const newLineIndex = code.indexOf('\n');
        if (newLineIndex > 0) {
            return `${code.substr(0, newLineIndex)}\n// @ts-nocheck\n${code.substr(newLineIndex + 1)}`;
        }
        else {
            return code;
        }
    }
    else {
        // We should leave comments, like `/** @jest-env jsdom */ at the top of the file, see #2569
        startingCommentRegex.lastIndex = 0;
        const commentMatch = startingCommentRegex.exec(code);
        return `${(_a = commentMatch === null || commentMatch === void 0 ? void 0 : commentMatch[1].concat('\n')) !== null && _a !== void 0 ? _a : ''}// @ts-nocheck\n${code.substr((_b = commentMatch === null || commentMatch === void 0 ? void 0 : commentMatch[1].length) !== null && _b !== void 0 ? _b : 0)}`;
    }
}
function disableTypeCheckingInHtml(ast) {
    const sortedScripts = [...ast.root.scripts].sort((a, b) => a.root.start - b.root.start);
    let currentIndex = 0;
    let html = '';
    for (const script of sortedScripts) {
        html += ast.rawContent.substring(currentIndex, script.root.start);
        html += '\n';
        html += prefixWithNoCheck(removeTSDirectives(script.rawContent, script.root.comments));
        html += '\n';
        currentIndex = script.root.end;
    }
    html += ast.rawContent.substring(currentIndex);
    return html;
}
function removeTSDirectives(text, comments) {
    const directiveRanges = comments === null || comments === void 0 ? void 0 : comments.map(tryParseTSDirective).filter(notEmpty).sort((a, b) => a.startPos - b.startPos);
    if (directiveRanges) {
        let currentIndex = 0;
        let pruned = '';
        for (const directiveRange of directiveRanges) {
            pruned += text.substring(currentIndex, directiveRange.startPos);
            currentIndex = directiveRange.endPos;
        }
        pruned += text.substring(currentIndex);
        return pruned;
    }
    else {
        return text;
    }
}
function tryParseTSDirective(comment) {
    const match = commentDirectiveRegEx.exec(comment.value);
    if (match) {
        const directiveStartPos = comment.start + match[1].length + 2; // +2 to account for the `//` or `/*` start character
        return { startPos: directiveStartPos, endPos: directiveStartPos + match[2].length + 1 };
    }
    return undefined;
}
//# sourceMappingURL=disable-type-checks.js.map