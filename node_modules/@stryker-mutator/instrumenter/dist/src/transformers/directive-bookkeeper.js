import { notEmpty } from '@stryker-mutator/util';
const WILDCARD = 'all';
const DEFAULT_REASON = 'Ignored using a comment';
class IgnoreRule {
    constructor(mutatorNames, line, ignoreReason, previousRule) {
        this.mutatorNames = mutatorNames;
        this.line = line;
        this.ignoreReason = ignoreReason;
        this.previousRule = previousRule;
    }
    matches(mutatorName, line) {
        const lineMatches = () => this.line === undefined || this.line === line;
        const mutatorMatches = () => this.mutatorNames.includes(mutatorName) || this.mutatorNames.includes(WILDCARD);
        return lineMatches() && mutatorMatches();
    }
    findIgnoreReason(mutatorName, line) {
        if (this.matches(mutatorName, line)) {
            return this.ignoreReason;
        }
        return this.previousRule.findIgnoreReason(mutatorName, line);
    }
}
class RestoreRule extends IgnoreRule {
    constructor(mutatorNames, line, previousRule) {
        super(mutatorNames, line, undefined, previousRule);
    }
}
const rootRule = {
    findIgnoreReason() {
        return undefined;
    },
};
/**
 * Responsible for the bookkeeping of "// Stryker" directives like "disable" and "restore".
 */
export class DirectiveBookkeeper {
    constructor() {
        // https://regex101.com/r/nWLLLm/1
        this.strykerCommentDirectiveRegex = /^\s?Stryker (disable|restore)(?: (next-line))? ([a-zA-Z, ]+)(?::(.+)?)?/;
        this.currentIgnoreRule = rootRule;
    }
    processStrykerDirectives({ loc, leadingComments }) {
        leadingComments === null || leadingComments === void 0 ? void 0 : leadingComments.map((comment) => this.strykerCommentDirectiveRegex.exec(comment.value)).filter(notEmpty).forEach(([, directiveType, scope, mutators, optionalReason]) => {
            const mutatorNames = mutators.split(',').map((mutator) => mutator.trim().toLowerCase());
            const reason = (optionalReason !== null && optionalReason !== void 0 ? optionalReason : DEFAULT_REASON).trim();
            switch (directiveType) {
                case 'disable':
                    switch (scope) {
                        case 'next-line':
                            this.currentIgnoreRule = new IgnoreRule(mutatorNames, loc.start.line, reason, this.currentIgnoreRule);
                            break;
                        default:
                            this.currentIgnoreRule = new IgnoreRule(mutatorNames, undefined, reason, this.currentIgnoreRule);
                            break;
                    }
                    break;
                case 'restore':
                    switch (scope) {
                        case 'next-line':
                            this.currentIgnoreRule = new RestoreRule(mutatorNames, loc.start.line, this.currentIgnoreRule);
                            break;
                        default:
                            this.currentIgnoreRule = new RestoreRule(mutatorNames, undefined, this.currentIgnoreRule);
                            break;
                    }
                    break;
            }
        });
    }
    findIgnoreReason(line, mutatorName) {
        mutatorName = mutatorName.toLowerCase();
        return this.currentIgnoreRule.findIgnoreReason(mutatorName, line);
    }
}
//# sourceMappingURL=directive-bookkeeper.js.map