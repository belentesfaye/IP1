import { EOL } from 'os';
import path from 'path';
import ts from 'typescript';
import { CheckStatus } from '@stryker-mutator/api/check';
import { tokens, commonTokens, Scope } from '@stryker-mutator/api/plugin';
import { Task, propertyPath } from '@stryker-mutator/util';
import { HybridFileSystem } from './fs/index.js';
import { determineBuildModeEnabled, overrideOptions, retrieveReferencedProjects, guardTSVersion, toPosixFileName } from './tsconfig-helpers.js';
import * as pluginTokens from './plugin-tokens.js';
const diagnosticsHost = {
    getCanonicalFileName: (fileName) => fileName,
    getCurrentDirectory: process.cwd,
    getNewLine: () => EOL,
};
const FILE_CHANGE_DETECTED_DIAGNOSTIC_CODE = 6032;
typescriptCheckerLoggerFactory.inject = tokens(commonTokens.getLogger, commonTokens.target);
// eslint-disable-next-line @typescript-eslint/ban-types
function typescriptCheckerLoggerFactory(loggerFactory, target) {
    var _a;
    const targetName = (_a = target === null || target === void 0 ? void 0 : target.name) !== null && _a !== void 0 ? _a : TypescriptChecker.name;
    const category = targetName === TypescriptChecker.name ? TypescriptChecker.name : `${TypescriptChecker.name}.${targetName}`;
    return loggerFactory(category);
}
create.inject = tokens(commonTokens.injector);
export function create(injector) {
    return injector
        .provideFactory(commonTokens.logger, typescriptCheckerLoggerFactory, Scope.Transient)
        .provideClass(pluginTokens.fs, HybridFileSystem)
        .injectClass(TypescriptChecker);
}
/**
 * An in-memory type checker implementation which validates type errors of mutants.
 */
export class TypescriptChecker {
    constructor(logger, options, fs) {
        this.logger = logger;
        this.fs = fs;
        this.currentTask = new Task();
        this.currentErrors = [];
        this.logDiagnostic = (label) => {
            return (d) => {
                this.logger.trace(`${label} ${ts.formatDiagnostics([d], diagnosticsHost)}`);
            };
        };
        this.tsconfigFile = toPosixFileName(options.tsconfigFile);
        this.allTSConfigFiles = new Set([path.resolve(this.tsconfigFile)]);
    }
    /**
     * Starts the typescript compiler and does a dry run
     */
    async init() {
        guardTSVersion();
        this.guardTSConfigFileExists();
        this.currentTask = new Task();
        const buildModeEnabled = determineBuildModeEnabled(this.tsconfigFile);
        const compiler = ts.createSolutionBuilderWithWatch(ts.createSolutionBuilderWithWatchHost({
            ...ts.sys,
            readFile: (fileName) => {
                var _a;
                const content = (_a = this.fs.getFile(fileName)) === null || _a === void 0 ? void 0 : _a.content;
                if (content && this.allTSConfigFiles.has(path.resolve(fileName))) {
                    return this.adjustTSConfigFile(fileName, content, buildModeEnabled);
                }
                return content;
            },
            watchFile: (filePath, callback) => {
                this.fs.watchFile(filePath, callback);
                return {
                    close: () => {
                        delete this.fs.getFile(filePath).watcher;
                    },
                };
            },
            writeFile: (filePath, data) => {
                this.fs.writeFile(filePath, data);
            },
            createDirectory: () => {
                // Idle, no need to create directories in the hybrid fs
            },
            clearScreen() {
                // idle, never clear the screen
            },
            getModifiedTime: (fileName) => {
                return this.fs.getFile(fileName).modifiedTime;
            },
            watchDirectory: () => {
                // this is used to see if new files are added to a directory. Can safely be ignored for mutation testing.
                return {
                    // eslint-disable-next-line @typescript-eslint/no-empty-function
                    close() { },
                };
            },
        }, undefined, (error) => this.currentErrors.push(error), (status) => this.logDiagnostic('status')(status), (summary) => {
            this.logDiagnostic('summary')(summary);
            summary.code !== FILE_CHANGE_DETECTED_DIAGNOSTIC_CODE && this.resolveCheckResult();
        }), [this.tsconfigFile], {});
        compiler.build();
        const result = await this.currentTask.promise;
        if (result.status === CheckStatus.CompileError) {
            throw new Error(`TypeScript error(s) found in dry run compilation: ${result.reason}`);
        }
    }
    guardTSConfigFileExists() {
        if (!ts.sys.fileExists(this.tsconfigFile)) {
            throw new Error(`The tsconfig file does not exist at: "${path.resolve(this.tsconfigFile)}". Please configure the tsconfig file in your stryker.conf file using "${propertyPath()('tsconfigFile')}"`);
        }
    }
    /**
     * Checks whether or not a mutant results in a compile error.
     * Will simply pass through if the file mutated isn't part of the typescript project
     * @param mutant The mutant to check
     */
    async check(mutants) {
        const mutant = mutants[0];
        if (this.fs.existsInMemory(mutant.fileName)) {
            this.clearCheckState();
            this.fs.mutate(mutant);
            return {
                [mutant.id]: await this.currentTask.promise,
            };
        }
        else {
            // We allow people to mutate files that are not included in this ts project
            return {
                [mutant.id]: {
                    status: CheckStatus.Passed,
                },
            };
        }
    }
    /**
     * Post processes the content of a tsconfig file. Adjusts some options for speed and alters quality options.
     * @param fileName The tsconfig file name
     * @param content The tsconfig content
     * @param buildModeEnabled Whether or not `--build` mode is used
     */
    adjustTSConfigFile(fileName, content, buildModeEnabled) {
        const parsedConfig = ts.parseConfigFileTextToJson(fileName, content);
        if (parsedConfig.error) {
            return content; // let the ts compiler deal with this error
        }
        else {
            for (const referencedProject of retrieveReferencedProjects(parsedConfig, path.dirname(fileName))) {
                this.allTSConfigFiles.add(referencedProject);
            }
            return overrideOptions(parsedConfig, buildModeEnabled);
        }
    }
    /**
     * Resolves the task that is currently running. Will report back the check result.
     */
    resolveCheckResult() {
        if (this.currentErrors.length) {
            const errorText = ts.formatDiagnostics(this.currentErrors, {
                getCanonicalFileName: (fileName) => fileName,
                getCurrentDirectory: process.cwd,
                getNewLine: () => EOL,
            });
            this.currentTask.resolve({
                status: CheckStatus.CompileError,
                reason: errorText,
            });
        }
        this.currentTask.resolve({ status: CheckStatus.Passed });
    }
    /**
     * Clear state between checks
     */
    clearCheckState() {
        while (this.currentErrors.pop()) {
            // Idle
        }
        this.currentTask = new Task();
    }
}
TypescriptChecker.inject = tokens(commonTokens.logger, commonTokens.options, pluginTokens.fs);
//# sourceMappingURL=typescript-checker.js.map